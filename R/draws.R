
draws_to_df <- function(samp, par_dim, column_lists = FALSE) {
    names(dimnames(samp)) <- c("iter", "chain", "parameter")
    df <- reshape2::melt(samp)
    par_names <- stringr::str_remove(df$parameter, r"(\[.+\])")
    tib <- df |>
        reshape2::dcast(chain + iter ~ parameter) |>
        tibble::tibble()

    tib <- tib[, 1:2]
    tib$chain <- as.integer(tib$chain)

    for (p in unique(par_names)) {
        column <- df[par_names == p, ] |>
            reshape2::acast(chain + iter ~ parameter)

        if (ncol(column) == 1L) {
            column <- column[, 1L]
        } else if (column_lists) {
            column <- apply(column, 1L, array, dim = par_dim[[p]], simplify = FALSE)
            column <- unname(column)
        }

        tib[[p]] <- column
    }

    structure(
        tib,
        class = c("thomas_draw_df", class(tib)),
        column_lists = column_lists,
        par_dim = par_dim
    )
}

#' @export
get_parameter_dim.thomas_draw_df <- function(fit) {
    attr(fit, "par_dim")
}

#' Extract a draw and reshape it to the dimensions of each parameter
#'
#' @param x Data frame containing the draws.
#' @param ... Indexes. You can select one row and any number columns.
#'
#' @returns A named list where each parameter has the right dimension.
#' @export
#'
#' @examples
#' draws <- get_draws(jags_fit)
#' draws[1, ]
#' draws[[1, ]]
#' draws[[1, "gamma"]]
`[[.thomas_draw_df` <- function(x, ...) {
    if (...length() == 1L) {
        return(unclass(x)[[...]])
    }
    if (...length() != 2L) {
        rlang::abort("Use draws[[i, ]] to extract exactly one draw.")
    }

    dots <- rlang::dots_list(..., .ignore_empty = "none", .preserve_empty = TRUE)

    if (rlang::is_missing(dots[[1L]])) {
        return(unclass(x)[[dots[[2L]]]])
    }
    if (length(dots[[1L]]) != 1L) {
        rlang::abort("Use draws[[i, ]] to extract exactly one draw.")
    }

    if (attr(x, "column_lists")) {
        y <- x[...]
        y <- lapply(y, \(v) v[[1]])
        return(y)
    }

    y <- x[...]
    y <- as.list(y)
    pd <- get_parameter_dim(x)

    for (k in seq_along(y)) {
        p <- names(y)[k]
        if (p %in% names(pd)) {
            y[[k]] <- array(y[[k]], dim = pd[[p]])
        }
    }

    if (length(y) == 1L) {
        y <- y[[1L]]
    }

    attr(y, "column_lists") <- NULL
    attr(y, "par_dim") <- NULL
    return(y)
}

drop_matrices <- function(df, max_cols = 4L) {
    df <- as.list(df)

    for (k in 1:length(df))  if (is.matrix(df[[k]])) {
        to <- max_cols |> min(ncol(df[[k]]))
        df[[k]] <- df[[k]][, 1:to] |> as.data.frame()
    }

    dplyr::bind_cols(df)
}

#' Plot chains to check convergence.
#'
#' @param fit A Bayesian Fit or a Draw Data Frame as generated by [get_draws()].
#' @param ... Parameters to select, passed to [dplyr::select()].
#' @param .max_values For multivariate parameters, number of different values to plot.
#' @param .show_chain Whether to show chain numbers in legend.
#'
#' @export
traceplot <- function(fit, ..., .max_values = 4L, .show_chain = TRUE) {

    rlang::check_installed("ggplot2")
    draws <- get_draws_anyway(fit)

    if (attr(draws, "column_lists")) {
        stop('`traceplot` not available for draws in "df_listed" format. ',
             'Use `get_draws(fit, as = "df")` instead.')
    }

    if (...length() == 0L) {
        draws <- draws[1:min(9L, ncol(draws))]
    } else {
        draws <- dplyr::select(draws, iter, chain, ...)
    }

    lp <- names(draws) %in% c("lp__", "deviance")

    draws <- draws[order(-lp)] |>
        drop_matrices(max_cols = .max_values) |>
        reshape2::melt(id.vars = c("chain", "iter")) |>
        dplyr::mutate(chain = factor(chain)) |>
        suppressWarnings()

    tp <- ggplot2::ggplot(draws, ggplot2::aes(x = iter, y = value, color = chain)) +
        ggplot2::facet_wrap(~variable, scales = "free") +
        ggplot2::geom_line(show.legend = .show_chain) +
        ggplot2::theme_minimal()

    plot(tp)
    invisible(tp)
}


#' Attach a draw or sample to an environment
#'
#' @param fit A Bayesian Fit or a Draw Data Frame as generated by [get_draws()].
#' @param index Integer indicating the row in `draws` to attach. Alternatively, you can
#' specify `chain` and `iter`.
#' @param chain Integer indicating the chain.
#' @param iter Integer indicating the within-chain iteration.
#' @param envir Environment, where to attach the draw. See [base::list2env()].
#'
#' @returns The draw as a list, invisibly.
#' @export
#'
#' @examples
#' for (i in 1:5) {
#'     attach_draw(jags_fit, index = i)
#'     print(beta)
#' }
attach_draw <- function(fit, index, chain, iter, envir = parent.frame()) {
    draws <- get_draws_anyway(fit)

    if (!missing(index)) {
        if (!rlang::is_integerish(index, n = 1L)) {
            rlang::abort("index must be an integer indicating a row in the draws data frame.")
        }
        if (!missing(chain) || !missing(iter)) {
            rlang::warn("index specified, ignoring chain and iter.")
        }

    } else if (!missing(chain) && !missing(iter)) {
        if (!rlang::is_integerish(chain, n = 1L) || !rlang::is_integerish(iter, n = 1L)) {
            rlang::abort(
                "chain and iter must be integers indicating the chain and the within-chain iteration."
            )
        }

        max_iter <- max(draws$iter)
        if (iter > max_iter) {
            rlang::abort(paste("iter is", iter, "but the fit only contains", max_iter, "per chain"))
        }

        index <- match(TRUE, draws$chain == chain & draws$iter == iter)
        if (is.na(index)) {
            rlang::abort("draw was not found")
        }

    } else {
        rlang::abort("You must either specify 'index', or 'chain' and 'iter'")
    }

    draw <- draws[[index, ]]
    list2env(draw, envir = envir)
    invisible(draw)
}
#' @rdname attach_draw
#' @export
attach_sample <- function(fit, index, chain, iter, envir = parent.frame()) {
    attach_draw(fit, index, chain, iter, envir)
}

#' Apply a function to each draw.
#'
#' The parameters have their defined dimensions.
#'
#' @param fit A Bayesian Fit or a Draw Data Frame as generated by [get_draws()].
#' @param fun Function that takes a draw. The parameters are referenced as `draw$parameter`.
#' @examples
#' map_draws(jags_fit, function(d) d$beta[1] + d$beta[2])
#' @export
map_draws <- function(fit, fun) {
    draws <- get_draws_anyway(fit)
    lapply(1:nrow(draws), function(draw_i) {
        draw <- draws[[draw_i, ]]
        fun(draw)
    })
}
