
#' Compile a Model with CmdStan
#'
#' @param file String indicating the file containing the model. Can either be
#' a .exe file with the compiled model or a .stan file containing the model code.
#' @param quiet Logical, wether to suppress messages.
#' @param ... Other arguments passed on to [cmdstanr::cmdstan_model()].
#'
#' @return A CmdStanModel object.
#' @export
cmdstan_model <- function(file = NULL, quiet = FALSE, ...) {

    rlang::check_installed("cmdstanr")

    wrap <- if (quiet) suppressMessages else identity
    if (stringr::str_detect(file, r"(\.exe$)"))
        wrap(cmdstanr::cmdstan_model(exe_file = file, compile = TRUE, ...))
    else
        wrap(cmdstanr::cmdstan_model(stan_file = file, compile = TRUE, ...))
}

#' @export
print.CmdStanModel <- function(x, ...) {
    cat("<Cmd Stan Model>\n")
    x$print()
}

#' @export
get_parameters.CmdStanModel <- function(x, ...) {
    names(x$variables()$parameters)
}


parse_cmdstan_inits <- function(inits, chains) {
    if (is.null(inits))
        return(NULL)
    if (rlang::is_function(inits))
        return(inits)
    if (rlang::is_atomic(inits))
        stop("`inits` must be a list, data.frame, or function.")

    if (is.data.frame(inits))
        inits <- apply(inits, 1L, as.list, simplify = FALSE)
    if (is.list(inits) && !is.null(names(inits)))
        stop("If `inits` is a list, it must be an unnamed list of named lists. ",
             "If you want to use the same `inits` for each chain, you can use `list(list(...))`")

    if (length(inits) == 1L)
        inits <- rep(inits, chains)
    if (length(inits) != chains)
        stop("`inits` must be either length 1, or the number of chains (", chains,").")
    inits
}

#' Fit a CmdStan model
#' @description
#' Generate posterior samples from a CmdStanModel using Markov Chain Monte-Carlo.
#' @param model CmdStanModel as generated by [thomas::cmdstan_model()] or [cmdstanr::cmdstan_model()].
#' @param file Alternatively, a .stan file containing the model code.
#' @param data List containing the data for fitting. Must contain all the variables
#' on the `data` block of the stan model.
#' @param inits Initial values for parameters. Accepts either:
#' - Unnamed list of a named list, with the initial values for the parameters. All chains will start
#' with these values. For example: \cr
#' `inits = list(list(a = 2, b = 1:5))`.
#' - List of named lists, where each element is a named list of values corresponding to a chain.
#' For example, with 2 chains: \cr
#' `inits = list(list(a = 2, b = 1:5), list(a = 3, b = 2:6))`
#' - Data.frame, where each row corresponds to a chain and each column corresponds to a parameter.
#' You can use a [tibble::tibble()] for multivariate parameters.
#' For example: with 2 chains: \cr
#' `inits = tibble::tibble(a = 2:3, b = list(1:5, 2:6))`
#' - Function. Takes an input `chain_id` and outputs a named list. For example: \cr
#' `inits = function(chain_id) { list(a = chain_id, b = rpois(5, 1.2)) }`
#' @param iter Number of iterations, including burnin, per chain.
#' @param burnin Number of samples to burn per chain.
#' @param warmup Alias for `burnin`.
#' @param thin Positive integer specifying the period for saving samples.
#' @param chains Positive integer specifying the number of Markov chains.
#' The default is 4.
#' @param seed Seed to use for the RNG.
#' @param ... Arguments passed on to [cmdstanr::sample()].
#' @seealso [cmdstanr::sample()]
#' @return A CmdStanMCMC object, inheriting CmdStanFit and R6.
#' @export
run_cmdstan <- function(model, file, data, inits = NULL,
                        iter = 2000, burnin = floor(iter/2), thin = 1,
                        chains = 4, warmup = burnin,
                        seed = NULL, ...) {

    rlang::check_installed("cmdstanr")

    if (missing(model) + missing(file) != 1L)
        stop("Specify either 'model' (see cmdstan_model()) or 'file'.")
    if (missing(model))
        model <- cmdstan_model(file)
    model$sample(
        data = data,
        init = parse_cmdstan_inits(inits, chains),

        iter_warmup = warmup,
        iter_sampling = iter - warmup,
        thin = thin,
        chains = chains,

        seed = seed,
        ...
    )
}

#' @export
    rlang::check_installed("cmdstanr")

    if (missing(model) + missing(file) != 1L)
        stop("Specify either 'model' (see cmdstan_model()) or 'file'.")
    if (missing(model))
        model <- cmdstan_model(file)
#' @export
run_cmdstan_optimizer <- function(model, file, data, inits = NULL, ...) {
    rlang::check_installed("cmdstanr")

    if (missing(model) + missing(file) != 1L)
        stop("Specify either 'model' (see cmdstan_model()) or 'file'.")
    if (missing(model))
        model <- cmdstan_model(file)

    model$optimize(
        data = data,
        init = parse_cmdstan_inits(inits, chains = 1L),
        ...
    )
}

#' @export
get_draws.CmdStanMCMC <- function(fit, as = c("df", "list", "array")) {
    as <- as[1L]
    draws <- fit$draws(format = "array")
    pd <- get_parameter_dim(fit)

    switch(as,
        df = draws_to_df(draws, pd),
        df_listed = draws_to_df(draws, pd, column_lists = TRUE),
        list = draws_to_df(draws, pd) |> as.list(),
        array = draws
    )
}

#' @export
get_parameter_dim.CmdStanFit <- function(fit) {
    fit$metadata()$stan_variable_sizes
}

#' @export
get_means.CmdStanMCMC <- function(fit) {
    d <- get_parameter_dim(fit)
    mapply(name = names(d), d = d, SIMPLIFY = FALSE, function(name, d) {
        fit$summary(name)$mean |> array(dim = d) |> suppressWarnings()
    })
}

#' @export
get_sd.CmdStanMCMC <- function(fit) {
    d <- get_parameter_dim(fit)
    mapply(name = names(d), d = d, SIMPLIFY = FALSE, function(name, d) {
        fit$summary(name)$sd |> array(dim = d) |> suppressWarnings()
    })
}

#' @export
get_mle.CmdStanMLE <- function(fit) {
    d <- get_parameter_dim(fit)
    out <- mapply(name = names(d), d = d, SIMPLIFY = FALSE, function(name, d) {
        fit$mle(name) |> array(dim = d)
    })

    out$lp__ <- fit$lp()
    out
}

#' @export
get_lp.CmdStanMLE <- function(fit) {
    fit$lp()
}
